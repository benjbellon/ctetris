#include <SDL3/SDL_error.h>
#include <SDL3/SDL_filesystem.h>
#include <SDL3/SDL_iostream.h>
#include <SDL3/SDL_rect.h>
#include <SDL3/SDL_stdinc.h>
#include <SDL3/SDL_surface.h>
#include <SDL3/SDL_timer.h>
#include <SDL3/SDL_video.h>
#include <stdlib.h>
#include <string.h>
#define SDL_MAIN_USE_CALLBACKS 1

#include <SDL3/SDL.h>
#include <SDL3/SDL_events.h>
#include <SDL3/SDL_init.h>
#include <SDL3/SDL_main.h>
#include <SDL3/SDL_oldnames.h>
#include <SDL3/SDL_render.h>
#include <stdio.h>

#define MAX_TETROMINOS 100

typedef struct SpriteSheet {
  SDL_Texture *sheet;
  int h;
  int w;
} SpriteSheet_t;

typedef struct SpriteSheetClip {
  int w;
  int h;
} SpriteSheetClip_t;

typedef struct Tetromino {
  SpriteSheet_t *sheet;
  SDL_FRect *clip;
  SDL_FRect *pos;
  int degrees_rotated;
} Tetromino_t;

static SDL_Window *window = NULL;
static SDL_Renderer *renderer = NULL;
static SpriteSheet_t tetromino_sheet = {0};
static Tetromino_t *tetrominos = NULL;
static bool new_tetromino = true;
static size_t total_tetrominos = 0;
static size_t game_height = 0;
static size_t game_width = 0;

static double LAST_TIME = 0.0;
static double UPDATE_RATE = 1000.0 / 10.0;

void physics() {
  // for each tetromino, make it fall
  // check if it collided

  // check if the i_th tetromino vioaltes a bound
  // start with board

  // collision detection
  // 1. if outside of board
  // 2. for tile at x if y + 128 < tile_at_x.pos-> y

  // fall...

  for (size_t i = 0; i < total_tetrominos; i++) {
    printf("total (%lu): update %lu\n", total_tetrominos, i);
    Tetromino_t curr = tetrominos[total_tetrominos - 1];

    // 1. board check
    if (curr.pos->y + 128 >= game_height || curr.pos->x - 32 <= 0 ||
        curr.pos->x + 32 >= game_width) {
      new_tetromino = true;
      break;
      // out of game bounds...
    }

    // step 1. check if the cross in bounds
    // step 2. for each square, check if it intersects
    // if curr_tetromino x + width_of_tetromina
  }

  tetrominos[total_tetrominos - 1].pos->y += 10;

  // collision detection just checks the latest tetromino against the bottom
  // heights we could cache that in bottom_heights or just run through the
  // tetrominos
}

void update() {
  if (SDL_GetTicks() - LAST_TIME < UPDATE_RATE) {
    return;
  }

  physics();

  if (new_tetromino) {
    printf("total (%lu): spawning...\n", total_tetrominos);
    tetrominos[total_tetrominos].clip = malloc(sizeof(SDL_Rect));
    tetrominos[total_tetrominos].pos = malloc(sizeof(SDL_Rect));

    tetrominos[total_tetrominos].sheet = &tetromino_sheet;
    tetrominos[total_tetrominos].clip->x = 64;
    tetrominos[total_tetrominos].clip->y = 0;
    tetrominos[total_tetrominos].clip->h = 128;
    tetrominos[total_tetrominos].clip->w = 64;

    tetrominos[total_tetrominos].pos->x = game_width / 2.0;
    tetrominos[total_tetrominos].pos->y = 0;
    tetrominos[total_tetrominos].pos->h = 128;
    tetrominos[total_tetrominos].pos->w = 128;

    printf("new tetronimo (x: %f, y: %f, h: %f, w: %f)\n",
           tetrominos[total_tetrominos].pos->x,
           tetrominos[total_tetrominos].pos->y,
           tetrominos[total_tetrominos].pos->h,
           tetrominos[total_tetrominos].pos->w);

    total_tetrominos += 1;
    new_tetromino = false;
  }

  // If not actively falling tetromino
  // 1. physics (e.g. falling, collision, etc...)
  // 2. logic (e.g. other stuff like AI...)

  // create new tetromino

  // do update logic...

  LAST_TIME = SDL_GetTicks();
}

SDL_AppResult SDL_AppInit(void **appstate, int argc, char *argv[]) {
  SDL_SetAppMetadata("Tetris", "1.0.0", "bellgame.tetris");

  if (!SDL_Init(SDL_INIT_VIDEO)) {
    SDL_Log("Failed to initalize video: %s", SDL_GetError());
    return SDL_APP_FAILURE;
  }

  SDL_Rect bounds;
  SDL_GetDisplayBounds(SDL_GetPrimaryDisplay(), &bounds);
  game_height = 500;
  game_width = 800;

  if (!SDL_CreateWindowAndRenderer("Tetris", game_width, game_height, 0,
                                   &window, &renderer)) {
    SDL_Log("Failed to create window and renderer: %s", SDL_GetError());
    return SDL_APP_FAILURE;
  }

  // init all things;
  tetrominos =
      malloc(sizeof(Tetromino_t) * MAX_TETROMINOS); /* 100 is a good max */

  // load all textures;

  char *bmp_path = NULL;
  SDL_asprintf(&bmp_path, "%sassets/tetronimo_I.bmp", SDL_GetBasePath());

  SDL_Surface *surface = NULL;
  surface = SDL_LoadBMP(bmp_path);

  if (!surface) {
    SDL_Log("cannot load surface: %s\n", SDL_GetError());
    return SDL_APP_FAILURE;
  }

  SDL_free(bmp_path);

  tetromino_sheet.h = surface->h;
  tetromino_sheet.w = surface->w;
  tetromino_sheet.sheet = SDL_CreateTextureFromSurface(renderer, surface);

  if (!tetromino_sheet.sheet) {
    SDL_Log("failed toap load texture %s: %s\n", "tetronimo", SDL_GetError());
    return SDL_APP_FAILURE;
  }

  SDL_DestroySurface(surface);

  return SDL_APP_CONTINUE;
}

SDL_AppResult SDL_AppEvent(void *appstate, SDL_Event *event) {
  if (event->type == SDL_EVENT_QUIT) {
    return SDL_APP_SUCCESS;
  }

  if (event->type == SDL_EVENT_KEY_DOWN) {
    if (event->key.scancode == SDL_SCANCODE_R) {
    }
  }

  return SDL_APP_CONTINUE;
}

SDL_AppResult SDL_AppIterate(void *appstate) {
  update();

  SDL_SetRenderDrawColor(renderer, 0xFF, 0xFF, 0xFF, 0);
  SDL_RenderClear(renderer);

  // render tetromino
  for (size_t i = 0; i < total_tetrominos; i++) {
    SDL_RenderTexture(renderer, tetrominos[i].sheet->sheet, tetrominos[i].clip,
                      tetrominos[i].pos);
  }

  SDL_RenderPresent(renderer);

  return SDL_APP_CONTINUE;
}

void SDL_AppQuit(void *appstate, SDL_AppResult result) {}
